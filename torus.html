<html>
  <head>
    <meta charset="utf-8" />
    <style>
      body {
        margin: 0;
        padding: 0;
        overscroll-behavior-x: none;
        overscroll-behavior-y: none;
      }
      #contents {
        display: grid;
        grid-template-columns: auto 1fr;
        grid-template-rows: auto auto;
        margin: 10px 0 0 10px;
      }
      .wrapper {
        position: relative;
        box-sizing: border-box;
        border: solid 1px #aaaaaa;
        margin: 0 10px 10px 0;
        display: flex;
        align-items: center;
        overflow: hidden;
      }
      .wrapper canvas {
        position: absolute;
        top: 0;
        left: 0;
      }
      #form {
        grid-column: 1;
        grid-row: 1;
        padding: 5px;
        justify-content: space-between;
      }
      #focal-length-meter {
        position: relative;
        height: 24px;
        width: 80%;
      }
      #focal-length-meter::before {
        content: "";
        position: absolute;
        display: block;
        width: 100%;
        height: 1px;
        top: 50%;
        border-top: solid 1px #aaaaaa;
      }
      #focal-length-meter-handle {
        position: absolute;
        top: 0;
        width: 10px;
        height: calc(100% - 2px);
        background-color: #ffffff;
        border: solid 1px #888888;
      }
      #display-wrapper {
        grid-column: 1;
        grid-row: 2;
      }
      #map-form {
        grid-column: 2;
        grid-row: 1;
      }
      #map-wrapper {
        grid-column: 2;
        grid-row: 2;
        display: flex;
        align-items: center;
      }
      #map-display-wrapper {
        margin: 0;
        border: none;
      }
      @media screen and (max-width: 1000px) {
        #contents {
          grid-template-columns: auto;
          grid-template-rows: auto auto auto auto;
        }
        #map-form {
          grid-column: 1;
          grid-row: 3;
        }
        #map-wrapper {
          grid-column: 1;
          grid-row: 4;
        }
      }
    </style>
  </head>
  <body>
    <div id="contents">
      <div class="wrapper left" id="form">
        <div id="title">中心点距離</div>
        <div id="focal-length-meter">
          <div id="focal-length-meter-handle"></div>
        </div>
      </div>
      <div class="wrapper canvas-wrapper left" id="display-wrapper">
        <canvas class="left-canvas" id="auxiliary-line"></canvas>
        <canvas class="left-canvas" id="display"></canvas>
      </div>
      <form class="wrapper right" id="map-form">
      </form>
      <div class="wrapper canvas-wrapper right" id="map-wrapper">
        <div class="wrapper right" id="map-display-wrapper">
          <canvas class="right-canvas" id="map-display"></canvas>
          <canvas class="right-canvas" id="map-display-position"></canvas>
        </div>
      </div>
    </div>
    <script>
      const RO = 150;
      const RI = 50;
      const latitudeL = 50;
      const longitudeL = 100;
      const startResolution = 9;
      const landPer = 0.3;
      const displaySize = 500;
      const displayRadius = displaySize / 2;
      const vectorSlideRadius = displaySize / 8 * 3;
      const positions = {};
      const surfaces = [];
      const lines = {};

      const displayContext = document.getElementById('display').getContext('2d');
      const auxiliaryLineContext =  document.getElementById('auxiliary-line').getContext('2d');
      const mapDisplayWrapper = document.getElementById('map-display-wrapper');
      const mapDisplay = document.getElementById('map-display');
      const mapDisplayContext = mapDisplay.getContext('2d');
      const mapDisplayPosition = document.getElementById('map-display-position');
      const mapDisplayPositionContext = mapDisplayPosition.getContext('2d');
      const meter = document.getElementById('focal-length-meter');
      const meterHandle = document.getElementById('focal-length-meter-handle');

      // 内部変数
      let focalLengthPercentage = 1.5;
      let moveSwitch = false;
      let latestMoveX = 0;
      let latestMoveY = 0;
      let latestBaseX = 0;
      let latestBaseY = 0;
      let latestPointerX = 0;
      let latestPointerY = 0;
      let mapBaseX = RO * -2 - 1;
      let mapBaseY = 0;
      let mapX = RO * -2 - 1;
      let mapY = 0;
      let moveType = 'vector';
      let animationSwitch = false;
      let animationStartSwitch = false;
      let animationTimeout = null;
      let momentPoses = {};
      let focalLengthSwitch = false;
      let mapMoveSwitch = false;
      let horizonDepth =  RO * RO / displaySize / focalLengthPercentage;
      let meterHandleDiffX = 0;
      // 位置軸: 静止状態の対象物の基本姿勢からの傾きを表す軸
      let positionAxisX = 0; // 位置軸のZ軸(正面方向軸)に対する角度(0 ~ π)
      let positionAxisY = 0; // 位置軸のY軸(上下方向軸)に対する角度(-π ~ π)
      let positionAxisL = 0; // 位置軸に対する回転角度(-π ~ π)
      // 回転軸: 自転するベースとなる軸
      let momentAxisX = 0; // 位置軸のZ軸(正面方向軸)に対する角度(0 ~ π)
      let momentAxisY = 0; // 位置軸のY軸(上下方向軸)に対する角度(-π ~ π)
      let momentAxisL = 0; // 位置軸に対する回転角度(-π ~ π)
      let diffAxisL = 0;
      let axisX = 0;
      let axisY = 0;
      let axisL = 0;

      Array.prototype.forEach.call(document.getElementsByClassName('left'), (elem) => {
        elem.style.width = `${displaySize}px`;
      });
      Array.prototype.forEach.call(document.getElementsByClassName('left-canvas'), (elem) => {
        elem.setAttribute('width', displaySize);
        elem.setAttribute('height', displaySize);
      });
      Array.prototype.forEach.call(document.getElementsByClassName('right'), (elem) => {
        elem.style.width = `${RO * 4}px`;
      });
      Array.prototype.forEach.call(document.getElementsByClassName('right-canvas'), (elem) => {
        elem.setAttribute('width', RO * 8);
        elem.setAttribute('height', RO * 4);
      });
      Array.prototype.forEach.call(document.getElementsByClassName('canvas-wrapper'), (elem) => {
        elem.style.height = `${displaySize}px`;
      });
      mapDisplay.style.top = `${mapY}px`;
      mapDisplay.style.left = `${mapX}px`;
      mapDisplayPosition.style.top = `${mapY}px`;
      mapDisplayPosition.style.left = `${mapX}px`;
      mapDisplayWrapper.style.height = `${RO * 2}px`;

      Array(latitudeL).fill(null).forEach((_1, i1) => {
        const T = Math.PI * 2 / latitudeL * i1;
        const W = Math.cos(T) * (RO - RI) / -2 + RI + (RO - RI) / 2;
        const H = Math.sin(T) * (RO - RI) / 2;
        const R = Math.pow(W * W + H * H, 1 / 2);
        const X = Math.acos(H / R);
        const ST = Math.PI * 2 / latitudeL * (i1 + 1 / 2);
        const SL = Math.cos(Math.PI / latitudeL) * (RO - RI) / 2;
        const SW = Math.cos(ST) * SL * -1 + RO - (RO - RI) / 2;
        const SH = Math.sin(ST) * SL * -1;
        const SR = Math.pow(SW * SW + SH * SH, 1 / 2);
        const SX = Math.asin(SH / SR) * (SW >= 0 ? 1 : -1) + Math.PI / 2;
        const i2 = i1 < latitudeL - 1 ? i1 + 1 : 0;

        surfaces[i1] = [];

        Array(longitudeL).fill(null).forEach((_2, k1) => {
          const Y = Math.PI * 2 / longitudeL * k1;
          const SY = Math.PI * 2 / longitudeL * (k1 + 1 / 2);
          const k2 = k1 < longitudeL - 1 ? k1 + 1 : 0;

          positions[`I${i1}.K${k1}`] = { R, X, Y };
          positions[`S${i1}.${k1}`] = { R: SR, X: SX, Y: SY };
          surfaces[i1][k1] = {
            C: [`I${i1}.K${k1}`, `I${i1}.K${k2}`, `I${i2}.K${k2}`, `I${i2}.K${k1}`],
            S: `S${i1}.${k1}`,
            B: `B${k1}`,
            G: 0,
          };
        });
      });

      Array(longitudeL).fill(null).forEach((_, k) => {
        const Y = Math.PI * 2 / longitudeL * k;

        positions[`R.${k}`] = { R: RO, X: Math.PI / 2, Y };
        positions[`P.${k}`] = { R: RI, X: Math.PI / 2, Y };
        positions[`B${k}`] = {
          R: RI + (RO - RI) / 2,
          X: Math.PI / 2,
          Y: Math.PI * 2 / longitudeL * (k + 1 / 2),
        };

        lines[`R.${k}`] = [`R.${k}`, `R.${(k + 1) % longitudeL}`];
        lines[`P.${k}`] = [`P.${k}`, `P.${(k + 1) % longitudeL}`];
      });

      Array(latitudeL).fill(null).forEach((_, i) => {
        const T = Math.PI * 2 / latitudeL * i;
        const W = Math.cos(T) * (RO - RI) / -2 + RI + (RO - RI) / 2;
        const H = Math.sin(T) * (RO - RI) / 2;
        const R = Math.pow(W * W + H * H, 1 / 2);
        const X = Math.acos(H / R);

        positions[`K0.${i}`] = { R, X, Y: 0 };
        positions[`K1.${i}`] = { R, X, Y: Math.PI / 2 };
        positions[`K2.${i}`] = { R, X, Y: Math.PI };
        positions[`K3.${i}`] = { R, X, Y: Math.PI / 2 * 3 };
        lines[`K0.${i}`] = [`K0.${i}`, `K0.${(i + 1) % latitudeL}`];
        lines[`K1.${i}`] = [`K1.${i}`, `K1.${(i + 1) % latitudeL}`];
        lines[`K2.${i}`] = [`K2.${i}`, `K2.${(i + 1) % latitudeL}`];
        lines[`K3.${i}`] = [`K3.${i}`, `K3.${(i + 1) % latitudeL}`];
      });
      positions['O'] = { R: 0, X: 0, Y: 0 };
      positions['N0'] = { R: RO, X: 0, Y: 0 };
      positions['N1'] = { R: RO * 2, X: 0, Y: 0 };
      positions['S0'] = { R: RO, X: Math.PI, Y: 0 };
      positions['S1'] = { R: RO * 2, X: Math.PI, Y: 0 };

      const lineCodes = Object.keys(lines);
      const surfaceCodes = Object.keys(surfaces);
      const positionCodes = Object.keys(positions);

      let prevResolution = startResolution;
      let resolution = startResolution + 4;
      let prevGrounds = [];
      let grounds = [];
      let groundCodes = [];

      // 初期設定
      Array(startResolution).fill(null).forEach((_1, i) => {
        prevGrounds[i] = [];

        const longitudeR = Math.round(longitudeL * startResolution / latitudeL);

        Array(longitudeR).fill(null).forEach((_2, k) => {
          prevGrounds[i][k] = 0;
          groundCodes.push([i, k]);
        });
      });
      Array(groundCodes.length - 1).fill(null).forEach((_, i) => {
        const i1 = groundCodes.length - i - 1;
        const i2 = Math.floor(Math.random() * (i1 + 1));
        [groundCodes[i1], groundCodes[i2]] = [groundCodes[i2], groundCodes[i1]];
      });
      Array(Math.round(groundCodes.length * landPer)).fill(null).forEach((_, n) => {
        const [i, k] = groundCodes[n];
        prevGrounds[i][k] = 1;
      });

      // 解像度による陸地の再計算
      const expandGradual = () => {
        const aroundLength = 0.3;

        grounds = [];

        let groundLength = 0;
        let landLength = 0;
        let groundValues = [];

        Array(resolution).fill(null).forEach((_1, i) => {
          grounds[i] = [];
          const prevI_1 = Math.floor((prevGrounds.length * i - aroundLength) / resolution);
          const prevI_2 = Math.ceil((prevGrounds.length * (i + 1) + aroundLength) / resolution) - 1;
          const longitudeR = Math.round(longitudeL * resolution / latitudeL);

          Array(longitudeR).fill(null).forEach((_2, k) => {
            let groundL = 0;
            let groundW = 0;

            Array(prevI_2 - prevI_1 + 1).fill(null).forEach((_, pi) => {
              const prevI = (prevI_1 + pi + prevGrounds.length) % prevGrounds.length;
              const prevK_1 = Math.floor((prevGrounds[prevI].length * k - aroundLength) / longitudeR);
              const prevK_2 = Math.ceil((prevGrounds[prevI].length * (k + 1) + aroundLength) / longitudeR) - 1;
              Array(prevK_2 - prevK_1 + 1).fill(null).forEach((_, pk) => {
                const prevK = (prevK_1 + pk + prevGrounds[prevI].length) % prevGrounds[prevI].length;

                groundL += 1;
                groundW += prevGrounds[prevI][prevK];
              });
            });

            grounds[i][k] = Math.random() <= groundW / groundL ? 1 : 0;
            groundLength ++;
            landLength += grounds[i][k];
            groundValues.push({ i, k, land: grounds[i][k] });
          });
        });

        Array(groundValues.length - 1).fill(null).forEach((_, i) => {
          const i1 = groundValues.length - i - 1;
          const i2 = Math.floor(Math.random() * (i1 + 1));
          [groundValues[i1], groundValues[i2]] = [groundValues[i2], groundValues[i1]];
        });

        groundValues.forEach((groundValue) => {
          if (Math.round() < 0.1) {
            return;
          }

          const { i, k, land } = groundValue;
          const iu = Math.max(0, i - 1);
          const id = Math.min(resolution - 1, i + 1);
          const ku1 = Math.floor(k * grounds[iu].length / grounds[i].length);
          const ku2 = Math.ceil((k + 1) * grounds[iu].length / grounds[i].length) - 1;
          const kd1 = Math.floor(k * grounds[id].length / grounds[i].length);
          const kd2 = Math.ceil((k + 1) * grounds[id].length / grounds[i].length) - 1;
          const aroundLands =
            Array(ku2 - ku1 + 1).fill(null).reduce((l, _, _k) => l + grounds[iu][ku1 + _k], 0) +
            Array(kd2 - kd1 + 1).fill(null).reduce((l, _, _k) => l + grounds[id][kd1 + _k], 0) +
            grounds[i][(k - 1 + grounds[i].length) % grounds[i].length] +
            grounds[i][(k + 1 + grounds[i].length) % grounds[i].length];
          const aroundLandLength = ku2 - ku1 + kd2 - kd1 + 4;
          if (grounds[i][k] === 1 && aroundLands / aroundLandLength <= 1 / 6 && landLength / groundLength > landPer) {
            grounds[i][k] = 0;
            landLength --;
          } else if (grounds[i][k] === 0 && aroundLands / aroundLandLength >= 5 / 6 && landLength / groundLength < landPer) {
            grounds[i][k] = 1;
            landLength ++;
          }
        });

        prevGrounds = grounds;
      };

      const drawStroke = (context, poses, centerLength = displayRadius, strokeStyle = null) => {
        if (strokeStyle) {
          context.strokeStyle = strokeStyle;
        }
        context.beginPath();
        poses.forEach(([X, Y], i) => {
          i === 0
            ? context.moveTo(centerLength + X, centerLength + Y)
            : context.lineTo(centerLength + X, centerLength + Y);
        });
        context.closePath();
        context.stroke();
      };

      const drawArc = (context, X, Y, R, BT, LT, centerLength = displayRadius, strokeStyle = null) => {
        if (strokeStyle) {
          context.strokeStyle = strokeStyle;
        }
        context.beginPath();
        context.arc(centerLength + X, centerLength + Y, R, BT - Math.PI, BT + LT - Math.PI);
        context.closePath();
        context.stroke();
      };

      const displayLands = () => {
        surfaces.forEach((isurfaces, i) => {
          const i_1 = Math.floor(grounds.length * i / latitudeL);
          const i_2 = Math.ceil(grounds.length * (i + 1) / latitudeL) - 1;

          isurfaces.forEach((surface, k) => {
              Array(i_2 - i_1 + 1).fill(null).forEach((_, pi) => {
                const k_1 = Math.floor(grounds[i_1 + pi].length * k / longitudeL);
                const k_2 = Math.ceil(grounds[i_1 + pi].length * (k + 1) / longitudeL) - 1;
                Array(k_2 - k_1 + 1).fill(null).forEach((_, pk) => {
                  surface.G = grounds[i_1 + pi][k_1 + pk];
                });
              });
          });
        });
      };

      const makeLand = () => {
        expandGradual();
        displayLands();
        output();
        outputMap();
        if (resolution < latitudeL) {
          resolution = Math.min(resolution + 4, latitudeL);
          setTimeout(makeLand, 50);
        }
      };

      const calculatePosition = (posCode) => {
        let [X, Y, Z] = [0, 0, 0];

        const RZ0 = Math.sin(positions[posCode].X); // Z面上の半径
        const LZ0 = Math.cos(positions[posCode].X); // Z軸上の中心点との距離
        const TZ1 = positions[posCode].Y + axisL; // 回転角度の加算
        const LX1 = Math.sin(TZ1) * RZ0; // 回転軸に対するX軸上の相対距離
        const LY1 = Math.cos(TZ1) * RZ0; // 回転軸に対するY軸上の相対距離
        const RX1 = Math.pow(LY1 * LY1 + LZ0 * LZ0, 1 / 2);
        const TX1 = RX1 > 0 ? (Math.acos(LZ0 / RX1) * (LY1 >= 0 ? 1 : -1)) : 0;
        const TX2 = TX1 + axisX;
        const LY2 = Math.sin(TX2) * RX1;
        const LZ2 = Math.cos(TX2) * RX1;
        const RZ2 = Math.pow(LX1 * LX1 + LY2 * LY2, 1 / 2);
        const TZ2 = RZ2 > 0 ? (Math.acos(LY2 / RZ2) * (LX1 > 0 ? 1 : -1)) : 0;
        const TZ3 = TZ2 + axisY;
        const LX3 = Math.sin(TZ3) * RZ2;
        const LY3 = Math.cos(TZ3) * RZ2;

        X = LX3 * positions[posCode].R;
        Y = LY3 * positions[posCode].R;
        Z = LZ2 * positions[posCode].R;
        L = 0;

        let LX = LX1 * positions[posCode].R;
        let LY = LY2 * positions[posCode].R;

        if (focalLengthPercentage) {
          const focalLength = displaySize * focalLengthPercentage;
          const focalCofficient = 1 / Math.abs((focalLength - Z) / focalLength);
          // 法線角度計算用(視点からの距離の2乗)
          L = Math.pow(focalLength - Z, 2) + X * X + Y * Y;
          [X, Y] = [X * focalCofficient, Y * focalCofficient];
          // 正面重複判別用
          [LX, LY] = [LX * focalCofficient, LY * focalCofficient];
        }

        return { X, Y, Z, LX, LY, L };
      };

      const splitMesh = (poses) => {
        const meshParams = [
          [1, 1], [1, 0], [1, -1],
          [0, 1], [0, 0], [0, -1],
          [-1, 1], [-1, 0], [-1, -1],
        ].map(([I, K]) => ({ I, K, C: [], minI: null, maxI: null, minK: null, maxK: null }));

        let phase = 0;
        let phaseI = 0;
        let phaseK = 0;
        let pi = null;
        let pk = null;

        poses.forEach(([i, k]) => {
          if (i === 0 && pi === latitudeL - 1) phaseI ++;
          if (i === latitudeL - 1 && pi === 0) phaseI --;
          if (k === 0 && pk === longitudeL - 1) phaseK ++;
          if (k === longitudeL - 1 && pk === 0) phaseK --;

          meshParams.forEach((param) => {
            const mi = param.I > phaseI ? 0 : param.I < phaseI ? latitudeL : i;
            const mk = param.K > phaseK ? 0 : param.K < phaseK ? longitudeL : k;
            if (param.C.length) {
              const [li, lk] = param.C[param.C.length - 1];
              if (mi === li && mk === lk) return;
            }
            param.C.push([mi, mk]);
            if (param.minI === null || param.minI > mi) param.minI = mi;
            if (param.maxI === null || param.maxI < mi) param.maxI = mi;
            if (param.minK === null || param.minK > mk) param.minK = mk;
            if (param.maxK === null || param.maxK < mk) param.maxK = mk;
          });

          pi = i;
          pk = k;
        });

        return meshParams
          .filter((p) => p.maxI > p.minI && p.maxK > p.minK)
          .map((p) => p.C);
      };

      const output = () => {
        momentPoses = {};

        positionCodes.forEach((posCode) => {
          momentPoses[posCode] = calculatePosition(posCode);
        });

        surfaces.forEach((isurfaces) => {
          isurfaces.forEach((surface) => {
            // 視点(O)~ドーナツ断面中心点(B)の距離の2乗がポリゴン中心点(S)~(B)・(O)~(S)の合計の2乗より小さい(∠(OSB)が直角より狭い)場合は、ポリゴンが視界に背いていると判断
            surface.D = momentPoses[surface.S].L + Math.pow((RO - RI) / 2, 2) <= momentPoses[surface.B].L;
            surface.Z = surface.C.reduce((Z, posCode) => Z + momentPoses[posCode].Z, 0);
          });
        });

        const ties = [];
        const meshes = [];
        let tiePhase = 0;
        let tieChain = [];

        Array(longitudeL).fill(null).forEach((_1, k1) => {
          ties[k1] = { K: k1, IS: 0, IE: 0, Z: null };

          Array(latitudeL).fill(null).forEach((_, i1) => {
            const i2 = (i1 + 1) % latitudeL;

            if (surfaces[i1][k1].D && !surfaces[i2][k1].D) ties[k1].IE = i1;
            if (surfaces[i2][k1].D && !surfaces[i1][k1].D) ties[k1].IS = i2;
            if (ties[k1].Z === null || ties[k1].Z < surfaces[i1][k1].Z) ties[k1].Z = surfaces[i1][k1].Z;
          });

          tieChain[k1] = k1;
        });

        const directionType = Math.abs(axisX) <= Math.PI / 2;
        const horizonSurfaces = [];
        const horizonBK = Math.floor(longitudeL * (2 / 4 - axisL / Math.PI / 2));
        let horizonMinX = 0;
        let horizonMaxX = 0;

        if (axisX !== 0) {
          Array(Math.floor(longitudeL / 4)).fill(null).forEach((_, k) => {
            [1, -1].forEach((direction) => {
              const k1 = direction === 1
                ? (horizonBK + k * direction + longitudeL) % longitudeL
                : (horizonBK + (k + 1) * direction + longitudeL) % longitudeL;
              const horizonSurface = directionType
                ? surfaces[ties[k1].IS][k1]
                : surfaces[ties[k1].IE][k1];
              const poses = directionType
                ? [momentPoses[horizonSurface.C[0]], momentPoses[horizonSurface.C[1]]]
                : [momentPoses[horizonSurface.C[2]], momentPoses[horizonSurface.C[3]]];
              const minX = Math.min(poses[0].LX, poses[1].LX);
              const maxX = Math.max(poses[0].LX, poses[1].LX);
              const minY = directionType
                ? Math.min(poses[0].LY, poses[1].LY)
                : Math.max(poses[0].LY, poses[1].LY);
              if (maxX <= horizonMaxX && minX >= horizonMinX) return;
              if (minX < horizonMinX) horizonMinX = minX;
              if (maxX > horizonMaxX) horizonMaxX = maxX;
              horizonSurfaces.push({ minX, maxX, minY, Z: horizonSurface.Z, C: poses });
            });
          });
        }

        ties.forEach((tie1, k1) => {
          const ib = directionType ? tie1.IS : tie1.IE;

          Array(latitudeL).fill(null).forEach((_, i) => {
            const i1 = directionType
              ? (ib + i) % latitudeL
              : (ib - i + latitudeL) % latitudeL;
            const surface1 = surfaces[i1][k1];
            if (surface1.D && (i1 < latitudeL / 4 || i1 > latitudeL / 4 * 3)) {
              const poses = directionType
                ? [momentPoses[surface1.C[2]], momentPoses[surface1.C[3]]]
                : [momentPoses[surface1.C[0]], momentPoses[surface1.C[1]]];
              const minX = Math.min(poses[0].LX, poses[1].LX);
              const maxX = Math.max(poses[0].LX, poses[1].LX);
              const maxY = directionType
                ? Math.max(poses[0].LY, poses[1].LY)
                : Math.min(poses[0].LY, poses[1].LY);
              const horizonY = horizonSurfaces.filter(
                (s) => minX < s.maxX && maxX > s.minX && surface1.Z < s.Z
              ).reduce(
                (res, s) => (res === null || (directionType ? res > s.minY : res < s.minY)) ? s.minY : res, null
              );
              if (horizonY !== null && (directionType ? horizonY > maxY : horizonY < maxY)) {
                surface1.D = false;
                if (directionType) {
                  tie1.IS = (ib + i + 1) % latitudeL;
                } else {
                  tie1.IE = (ib - i - 1 + latitudeL) % latitudeL;
                }
              }
            }
          });
        });

        ties.forEach((tie1, k1) => {
          const tie2 = ties[(k1 + 1) % longitudeL];
          const [tieM, tieS] = tie1.Z > tie2.Z ? [tie1, tie2] : [tie2, tie1];
          const surfaceSS = surfaces[(tieM.IS - 1 + latitudeL) % latitudeL][tieS.K];
          const surfaceSE = surfaces[(tieM.IE + 1) % latitudeL][tieS.K];
          if (surfaceSS.D || surfaceSE.D) return;
          if (Array(latitudeL).fill(1).every(
            (_, i) =>
              !surfaces[i][tieS.K].D ||
              !surfaces[i][tieM.K].D
          )) return;
          const tieSK = tieChain[tieS.K];
          tieChain.forEach((param, k) => {
            if (param === tieSK) tieChain[k] = tieChain[tieM.K];
          });
        });

        const tie0 = ties.find((tie1) => tieChain[tie1.K] !== tieChain[(tie1.K - 1 + longitudeL) % longitudeL]) || ties[0];

        Array(longitudeL).fill(null).forEach((_, k) => {
          const k1 = (tie0.K + k) % longitudeL;
          const k0 = (k1 - 1 + longitudeL) % longitudeL;
          const k2 = (k1 + 1) % longitudeL;
          const tie1 = ties[k1];
          const KS = tieChain[k0] !== tieChain[k1] || !meshes[tiePhase];
          const KE = tieChain[k1] !== tieChain[k2] || k2 === tie0.K;
          const KT = ((KC) => KC ? KC.P : null)(
            [0, 1, 2, 3].map(
              (KP) => ({ P: KP, K: Math.floor(longitudeL / 4 * KP) })
            ).find((C) => C.K === k1)
          );

          if (KS) {
            if (meshes[tiePhase]) tiePhase ++;
            meshes[tiePhase] = { L: [], H: [[], []], G: [], R: [[]], P: [], M: [], Z: 0 };
          }

          const mesh = meshes[tiePhase];
          const L = [[], [], [], []];
          const H = [[], [], [], []];
          const G = [];
          const M = [];
          let [LIL, LIR, HIL, HIR, GI, RI] = [0, 2, 0, 2, 0, 0];

          mesh.Z = Math.max(mesh.Z, tie1.Z);

          Array(latitudeL).fill(null).forEach((_, i) => {
            const i1 = (tie1.IS + i) % latitudeL;
            const i2 = (i1 + 1) % latitudeL;
            const surface1 = surfaces[i1][k1];
            const surface0 = surfaces[i1][k0];
            const surface2 = surfaces[i1][k2];

            if (surface1.D) {
              if (i1 === tie1.IS) {
                L[LIL].push([i1, k1], [i1, k2]);
                H[HIL].push(surface1.C[0], surface1.C[1]);
              }
              if (!surface0.D || KS) {
                L[LIL].unshift([i2, k1], [i1, k1]);
              } else {
                LIL = 1;
              }
              if (!surface0.D) {
                H[HIL].unshift(surface1.C[3], surface1.C[0]);
              } else {
                HIL = 1;
              }
              if (!surface2.D || KE) {
                L[LIR].push([i1, k2], [i2, k2]);
              } else {
                LIR = 3;
              }
              if (!surface2.D) {
                H[HIR].push(surface1.C[1], surface1.C[2]);
              } else {
                HIR = 3;
              }
              if (i1 === tie1.IE) {
                L[LIL].unshift([i2, k2], [i2, k1]);
                H[HIL].unshift(surface1.C[2], surface1.C[3]);
                mesh.L = L[3].concat(L[1]).concat(mesh.L).concat(L[0]).concat(L[2]);
                mesh.H[0] = mesh.H[0].concat(H[0]).concat(H[2]);
                mesh.H[1] = H[3].concat(H[1]).concat(mesh.H[1]);
              }

              if (surface1.G === 1) {
                if (!G[GI]) {
                  // G[GI] = [[surface1.C[0]], [surface1.C[1]]];
                  G[GI] = [[[i1, k1]], [[i1, k2]]];
                }

                // G[GI][0].unshift(surface1.C[3]);
                // G[GI][1].push(surface1.C[2]);
                G[GI][0].unshift([i2, k1]);
                G[GI][1].push([i2, k2]);
              } else if (G[GI]) {
                GI ++;
              }

              if (KT !== null) {
                if (i1 === tie1.IS) {
                  M.push(`K${KT}.${i1}`);
                }
                M.push(`K${KT}.${(i1 + 1) % latitudeL}`);
                if (i1 === tie1.IE) {
                  mesh.M.push({ P: KT, C: M });
                }
              }

              if (i1 === 0) {
                if (!mesh.P.length) {
                  mesh.P.push(`P.${k1}`);
                }
                mesh.P.push(`P.${k2}`);
              }

              if (i1 === Math.floor(latitudeL / 2) - 1) {
                if (!mesh.R[RI].length) {
                  mesh.R[RI].push(`R.${k1}`);
                }
                if (mesh.R[RI][mesh.R[RI].length - 1] !== `R.${k1}`) {
                  RI ++;
                  mesh.R[RI] = [`R.${k1}`];
                }
                mesh.R[RI].push(`R.${k2}`);
              }
            }
          });

          if (G.length) {
            mesh.G.push(G);
          }
        });

        meshes.sort((A, B) => A.Z - B.Z);

        const axises = [
          { P: 'N', C: momentPoses.N1, S: '#aa0000' },
          { P: 'S', C: momentPoses.S1, S: '#0000aa' },
        ].sort((A, B) => A.C.Z - B.C.Z);

        displayContext.clearRect(0, 0, displaySize, displaySize);
        mapDisplayPositionContext.clearRect(0, 0, RO * 8, RO * 4);

        meshes.forEach((mesh, n) => {
          if (n === 0) {
            displayContext.strokeStyle = axises[0].S;
            displayContext.beginPath();
            displayContext.moveTo(displayRadius, displayRadius);
            displayContext.lineTo(displayRadius + axises[0].C.X, displayRadius + axises[0].C.Y);
            displayContext.stroke();
          }

          displayContext.fillStyle = '#0066ff';
          displayContext.strokeStyle = '#0066ff';
          displayContext.beginPath();
          mesh.L.forEach(([i, k], j) => {
            const posCode = `I${i}.K${k}`;
            const pos = momentPoses[posCode];
            if (j === 0) {
              displayContext.moveTo(displayRadius + pos.X, displayRadius + pos.Y);
            } else if (i !== mesh.L[j - 1][0] || k !== mesh.L[j - 1][1]) {
              displayContext.lineTo(displayRadius + pos.X, displayRadius + pos.Y);
            }
          });
          displayContext.closePath();
          displayContext.fill();
          displayContext.save();
          displayContext.globalCompositeOperation = 'destination-over';
          displayContext.stroke();
          displayContext.restore();

          displayContext.fillStyle = '#88ff88';
          displayContext.strokeStyle = '#88ff88';

          mesh.G.forEach((Gs) => {
            Gs.forEach((G) => {
              displayContext.beginPath();
              G[0].concat(G[1]).forEach(([i, k], j) => {
                const posCode = `I${i}.K${k}`;
                const pos = momentPoses[posCode];
                if (j === 0) {
                  displayContext.moveTo(displayRadius + pos.X, displayRadius + pos.Y);
                } else {
                  displayContext.lineTo(displayRadius + pos.X, displayRadius + pos.Y);
                }
              });
              displayContext.closePath();
              displayContext.fill();
              displayContext.stroke();
            });
          });

          mesh.M.forEach((M, i) => {
            displayContext.strokeStyle = [0, 2].includes(M.P) ? '#ffffff' : '#8888ff';
            displayContext.beginPath();
            M.C.forEach((posCode, j) => {
              const pos = momentPoses[posCode];
              if (j === 0) {
                displayContext.moveTo(displayRadius + pos.X, displayRadius + pos.Y);
              } else {
                displayContext.lineTo(displayRadius + pos.X, displayRadius + pos.Y);
              }
            });
            displayContext.stroke();
          });

          if (mesh.P.length) {
            displayContext.strokeStyle = '#88aaff';
            displayContext.beginPath();
            mesh.P.forEach((posCode, j) => {
              const pos = momentPoses[posCode];
              if (j === 0) {
                displayContext.moveTo(displayRadius + pos.X, displayRadius + pos.Y);
              } else {
                displayContext.lineTo(displayRadius + pos.X, displayRadius + pos.Y);
              }
            });
            displayContext.stroke();
          }

          mesh.R.forEach((Ls, i) => {
            if (Ls.length) {
              displayContext.strokeStyle = '#ff0000';
              displayContext.beginPath();
              Ls.forEach((posCode, j) => {
                const pos = momentPoses[posCode];
                if (j === 0) {
                  displayContext.moveTo(displayRadius + pos.X, displayRadius + pos.Y);
                } else {
                  displayContext.lineTo(displayRadius + pos.X, displayRadius + pos.Y);
                }
              });
              displayContext.stroke();
            }
          });

          displayContext.strokeStyle = '#000000';

          mesh.H.forEach((H, i) => {
            if (H.length) {
              displayContext.beginPath();
              H.forEach((posCode, j) => {
                const pos = momentPoses[posCode];
                if (j === 0) {
                  displayContext.moveTo(displayRadius + pos.X, displayRadius + pos.Y);
                } else if (posCode !== H[j - 1]) {
                  displayContext.lineTo(displayRadius + pos.X, displayRadius + pos.Y);
                }
              });
              displayContext.stroke();
            }
          });

          if (meshes.length === 1 || n === meshes.length - 2) {
            displayContext.strokeStyle = axises[1].S;
            displayContext.beginPath();
            displayContext.moveTo(displayRadius, displayRadius);
            displayContext.lineTo(displayRadius + axises[1].C.X, displayRadius + axises[1].C.Y);
            displayContext.stroke();
          }

          mapDisplayPositionContext.fillStyle = '#0066ff';
          splitMesh(mesh.L).forEach((L) => {
            Array(4).fill(null).forEach((_, p) => {
              const py = Math.floor(p / 2);
              const px = p % 2;
              mapDisplayPositionContext.beginPath();
              L.forEach(([i, k], j) => {
                const X = RO * 4 * px + RO * 4 / longitudeL * k;
                const Y = RO * 2 * py + RO * 2 / latitudeL * i;
                if (j === 0) {
                  mapDisplayPositionContext.moveTo(X, Y);
                } else {
                  mapDisplayPositionContext.lineTo(X, Y);
                }
              });
              mapDisplayPositionContext.closePath();
              mapDisplayPositionContext.fill();
            });
          });

          const meshGs = [];

          mesh.G.forEach((Gs) => {
            Gs.forEach((G) => {
              splitMesh(G[0].concat(G[1])).forEach((meshG) => {
                meshGs.push(meshG);
              });
            });
          });

          mapDisplayPositionContext.fillStyle = '#88ff88';

          meshGs.forEach((G) => {
            Array(4).fill(null).forEach((_, p) => {
              const py = Math.floor(p / 2);
              const px = p % 2;
              mapDisplayPositionContext.beginPath();
              G.forEach(([i, k], j) => {
                const X = RO * 4 * px + RO * 4 / longitudeL * k;
                const Y = RO * 2 * py + RO * 2 / latitudeL * i;
                if (j === 0) {
                  mapDisplayPositionContext.moveTo(X, Y);
                } else {
                  mapDisplayPositionContext.lineTo(X, Y);
                }
              });
              mapDisplayPositionContext.closePath();
              mapDisplayPositionContext.fill();
            });
          });
        });

        drawStroke(mapDisplayPositionContext, [[RO, 0], [RO, RO * 4]], 0.5, '#8888ff');
        drawStroke(mapDisplayPositionContext, [[RO * 3, 0], [RO * 3, RO * 4]], 0.5, '#8888ff');
        drawStroke(mapDisplayPositionContext, [[RO * 5, 0], [RO * 5, RO * 4]], 0.5, '#8888ff');
        drawStroke(mapDisplayPositionContext, [[RO * 7, 0], [RO * 7, RO * 4]], 0.5, '#8888ff');
        drawStroke(mapDisplayPositionContext, [[RO * 2, 0], [RO * 2, RO * 4]], 0.5, '#ffffff');
        drawStroke(mapDisplayPositionContext, [[RO * 4, 0], [RO * 4, RO * 4]], 0.5, '#ffffff');
        drawStroke(mapDisplayPositionContext, [[RO * 6, 0], [RO * 6, RO * 4]], 0.5, '#ffffff');
        drawStroke(mapDisplayPositionContext, [[0, RO], [RO * 8, RO]], 0.5, '#ff0000');
        drawStroke(mapDisplayPositionContext, [[0, RO * 3], [RO * 8, RO * 3]], 0.5, '#ff0000');
        drawStroke(mapDisplayPositionContext, [[0, RO * 2], [RO * 8, RO * 2]], 0.5, '#88aaff');
      };

      const outputAuxiliaryLine = () => {
        const focalLength = displaySize * focalLengthPercentage;
        const Z2 = Math.pow(focalLength * focalLength - RO * RO, 1 / 2);
        const ER = RO / Z2 * focalLength;

        auxiliaryLineContext.clearRect(0, 0, displaySize, displaySize);
        drawArc(auxiliaryLineContext, 0.5, 0.5, vectorSlideRadius, 0, Math.PI * 2, displayRadius, '#eeeeee');
        drawStroke(auxiliaryLineContext, [[displayRadius * -1, 0.5], [displayRadius, 0.5]], displayRadius, '#aaaaaa');
        drawStroke(auxiliaryLineContext, [[0.5, displayRadius * -1], [0.5, displayRadius]], displayRadius, '#aaaaaa');
      };

      const outputMap = () => {
        mapDisplayContext.fillStyle = '#0044cc';
        mapDisplayContext.fillRect(0, 0, RO * 8, RO * 4);
        mapDisplayContext.strokeStyle = '#66cc66';
        mapDisplayContext.fillStyle = '#66cc66';

        const [yws, ywt] = grounds.reduce(([_yws, _ywt], ig, i) => {
          const [yu, yd] = _yws[_yws.length - 1] || [0, 0];

          return [[..._yws, [yd, yd + 1]], _ywt + 1];
        }, [[], 0]);

        [0, 1].forEach((py) => {
          grounds.forEach((igrounds, i) => {
            const y1 = RO * 2 * (py + 1 / grounds.length * i);
            const y2 = RO * 2 * (py + 1 / grounds.length * (i + 1));

            [0, 1].forEach((px) => {
              igrounds.forEach((ground, k) => {
                if (ground === 1) {
                  const x1 = RO * 4 * (px + 1 / igrounds.length * k);
                  const x2 = RO * 4 * (px + 1 / igrounds.length * (k + 1));
                  mapDisplayContext.beginPath();
                  mapDisplayContext.moveTo(x1, y1);
                  mapDisplayContext.lineTo(x2, y1);
                  mapDisplayContext.lineTo(x2, y2);
                  mapDisplayContext.lineTo(x1, y2);
                  mapDisplayContext.closePath();
                  mapDisplayContext.fill();
                  mapDisplayContext.stroke();
                }
              });
            });
          });
        });
      };

      const move = () => {
        positionAxisX = axisX;
        positionAxisY = axisY;
        positionAxisL = axisL;

        if (moveType === 'vector') {
          const diffX = latestMoveX - latestBaseX;
          const diffY = latestMoveY - latestBaseY;
          const diffL = Math.pow(diffX * diffX + diffY * diffY, 1 / 2);
          const diffR = Math.max(diffL, displayRadius / 100);

          if (diffL > 0) {
            momentAxisY = Math.acos(diffY / diffL) * (diffX >= 0 ? 1 : -1) + Math.PI / 2;
          }
          momentAxisX = Math.PI / 2;
          momentAxisL = 0;
          diffAxisL = diffR > 0 ? Math.asin(diffR / displayRadius) : 0;
        } else {
          const X1 = latestBaseX - displayRadius;
          const Y1 = latestBaseY - displayRadius;
          const X2 = latestMoveX - displayRadius;
          const Y2 = latestMoveY - displayRadius;
          const L1 = Math.pow(X1 * X1 + Y1 * Y1, 1 / 2);
          const L2 = Math.pow(X2 * X2 + Y2 * Y2, 1 / 2);
          const T1 = L1 > 0 ? Math.acos(Y1 / L1) * (X1 >= 0 ? 1 : -1) : 0;
          const T2 = L2 > 0 ? Math.acos(Y2 / L2) * (X2 >= 0 ? 1 : -1) : 0;

          momentAxisX = 0;
          momentAxisY = 0;
          momentAxisL = 0;
          diffAxisL = T2 - T1;
        }

        outputAuxiliaryLine();

        latestBaseX = latestMoveX;
        latestBaseY = latestMoveY;
      };

      const slide = () => {
        momentAxisL += diffAxisL;

        const RZ0 = Math.sin(positionAxisX); // Z面上の半径
        const LZ0 = Math.cos(positionAxisX); // Z軸上の中心点との距離
        const TZ1 = positionAxisY - momentAxisY; // 回転軸に対するZ面上の相対角度
        const LX1 = Math.sin(TZ1) * RZ0; // 回転軸に対するX軸上の相対距離
        const LY1 = Math.cos(TZ1) * RZ0; // 回転軸に対するY軸上の相対距離
        const RX1 = Math.pow(LY1 * LY1 + LZ0 * LZ0, 1 / 2);
        const TX1 = RX1 > 0 ? Math.acos(LZ0 / RX1) * (LY1 >= 0 ? 1 : -1) : 0;
        const TX2 = TX1 - momentAxisX; // 回転軸に対するX面上の相対角度
        const LY2 = Math.sin(TX2) * RX1;
        const LZ2 = Math.cos(TX2) * RX1;
        const RZ2 = Math.pow(LX1 * LX1 + LY2 * LY2, 1 / 2);
        const TZ2 = RZ2 > 0 ? Math.acos(LY2 / RZ2) * (LX1 >= 0 ? 1 : -1) : 0;
        const TZ3 = TZ2 + momentAxisL; // 回転角度に対するZ面上の相対角度
        const LX3 = Math.sin(TZ3) * RZ2;
        const LY3 = Math.cos(TZ3) * RZ2;
        const RX3 = Math.pow(LY3 * LY3 + LZ2 * LZ2, 1 / 2);
        const TX3 = RX3 > 0 ? Math.acos(LZ2 / RX3) * (LY3 >= 0 ? 1 : -1) : 0;
        const TX4 = TX3 + momentAxisX;
        const LY4 = Math.sin(TX4) * RX3;
        const LZ4 = Math.cos(TX4) * RX3;
        const RZ4 = Math.pow(LX3 * LX3 + LY4 * LY4, 1 / 2);
        const TZ4 = RZ4 > 0 ? Math.acos(LY4 / RZ4) * (LX3 >= 0 ? 1 : -1) : 0;
        const TZ5 = TZ4 + momentAxisY;
        const RX5 = Math.pow(RZ4 * RZ4 + LZ4 * LZ4, 1 / 2);
        const TX5 = RX5 > 0 ? Math.acos(LZ4 / RX5) : 0;

        const L_LX0 = Math.sin(positionAxisL);
        const L_LY0 = Math.cos(positionAxisL) * Math.cos(positionAxisX);
        const L_LZ0 = Math.cos(positionAxisL) * Math.sin(positionAxisX) * -1;
        const L_RZ0 = Math.pow(L_LX0 * L_LX0 + L_LY0 * L_LY0, 1 / 2);
        const L_TZ0 = L_RZ0 > 0 ? Math.acos(L_LY0 / L_RZ0) * (L_LX0 >= 0 ? 1 : -1) : 0;
        const L_TZ1 = L_TZ0 + positionAxisY - momentAxisY;
        const L_LX1 = Math.sin(L_TZ1) * L_RZ0;
        const L_LY1 = Math.cos(L_TZ1) * L_RZ0;
        const L_RX1 = Math.pow(L_LY1 * L_LY1 + L_LZ0 * L_LZ0, 1 / 2);
        const L_TX1 = L_RX1 > 0 ? Math.acos(L_LZ0 / L_RX1) * (L_LY1 >= 0 ? 1 : -1) : 0;
        const L_TX2 = L_TX1 - momentAxisX;
        const L_LY2 = Math.sin(L_TX2) * L_RX1;
        const L_LZ2 = Math.cos(L_TX2) * L_RX1;
        const L_RZ2 = Math.pow(L_LX1 * L_LX1 + L_LY2 * L_LY2, 1 / 2);
        const L_TZ2 = L_RZ2 > 0 ? Math.acos(L_LY2 / L_RZ2) * (L_LX1 >= 0 ? 1 : -1) : 0;
        const L_TZ3 = L_TZ2 + momentAxisL;
        const L_LX3 = Math.sin(L_TZ3) * L_RZ2;
        const L_LY3 = Math.cos(L_TZ3) * L_RZ2;
        const L_RX3 = Math.pow(L_LY3 * L_LY3 + L_LZ2 * L_LZ2, 1 / 2);
        const L_TX3 = L_RX3 > 0 ? Math.acos(L_LZ2 / L_RX3) * (L_LY3 >= 0 ? 1 : -1) : 0;
        const L_TX4 = L_TX3 + momentAxisX;
        const L_LY4 = Math.sin(L_TX4) * L_RX3;
        const L_LZ4 = Math.cos(L_TX4) * L_RX3;
        const L_RZ4 = Math.pow(L_LX3 * L_LX3 + L_LY4 * L_LY4, 1 / 2);
        const L_TZ4 = L_RZ4 > 0 ? Math.acos(L_LY4 / L_RZ4) * (L_LX3 >= 0 ? 1 : -1) : 0;
        const L_TZ5 = L_TZ4 - TZ4;
        const L_LX5 = Math.sin(L_TZ5) * L_RZ4;
        const L_LY5 = Math.cos(L_TZ5) * L_RZ4;
        const L_RX5 = Math.pow(L_LY5 * L_LY5 + L_LZ4 * L_LZ4, 1 / 2);
        const L_TX5 = L_RX5 > 0 ? Math.acos(L_LZ4 / L_RX5) * (L_LY5 >= 0 ? 1 : -1) : 0;
        const L_TX6 = L_TX5 - TX5;
        const L_LY6 = Math.sin(L_TX6) * L_RX5;
        const L_RZ6 = Math.pow(L_LX5 * L_LX5 + L_LY6 * L_LY6, 1 / 2);
        const L_TZ6 = L_RZ6 > 0 ? Math.acos(L_LY6 / L_RZ6) * (L_LX5 >= 0 ? 1 : -1) : 0;

        axisX = TX5;
        axisY = TZ5;
        axisL = L_TZ6;
      };

      const animate = () => {
        if (moveSwitch === true) move();
        slide();
        output();

        if (animationSwitch) {
          setTimeout(animate, 25);
        }
      };

      const startAnimation = () => {
        animationSwitch = true;
        animate();
      };

      const stopAnimation = () => {
        animationSwitch = false;
        animationStartSwitch = false;
      };

      const moveStopCheck = (clientX, clientY) => {
        animationStartSwitch = latestMoveX !== clientX || latestMoveY !== clientY;
      };

      const getMeterParams = () => {
        const meterRect = meter.getBoundingClientRect();
        const meterHandleRect = meterHandle.getBoundingClientRect();

        return {
          left: meterRect.left + meterHandleRect.width / 2,
          right: meterRect.left + meterRect.width - meterHandleRect.width / 2,
        };
      };

      const setMeterPosition = (percentage) => {
        const { left, right } = getMeterParams();
        meterHandle.style.left = `${Math.floor((right - left) * percentage)}px`;
      };

      const setFocalLengthSwitch = (operate, clientX) => {
        focalLengthSwitch = operate;
        if (operate === false) return;

        const meterHandleRect = meterHandle.getBoundingClientRect();
        if (clientX >= meterHandleRect.left && clientX <= meterHandleRect.left + meterHandleRect.width) {
          meterHandleDiffX = clientX - (meterHandleRect.left + meterHandleRect.width / 2);
        } else {
          meterHandleDiffX = 0;
          setFocalLength(clientX);
        }
      };

      const setFocalLength = (clientX) => {
        const { left, right } = getMeterParams();
        let percentage = (clientX - meterHandleDiffX - left) / (right - left);
        if (percentage < 0) percentage = 0;
        if (percentage > 1) percentage = 1;
        setMeterPosition(percentage);
        focalLengthPercentage = 1 / 2 + 2 * percentage;

        const focalLength = displaySize * focalLengthPercentage;
        horizonDepth = RO * RO / focalLength;

        outputAuxiliaryLine();
        if (!animationSwitch) output();
      };

      const moveMap = (X, Y) => {
        mapX = (mapBaseX + X - latestPointerX) % (RO * 4);
        mapY = (mapBaseY + Y - latestPointerY) % (RO * 2);
        if (mapX > 0) mapX -= RO * 4;
        if (mapY > 0) mapY -= RO * 2;
        mapDisplay.style.top = `${mapY}px`;
        mapDisplay.style.left = `${mapX}px`;
        mapDisplayPosition.style.top = `${mapY}px`;
        mapDisplayPosition.style.left = `${mapX}px`;
      };

      const getClientPosition = (event) => ({
        X: event.clientX !== undefined ? event.clientX : event.changedTouches[0].clientX,
        Y: event.clientY !== undefined ? event.clientY : event.changedTouches[0].clientY,
      });

      const displayOnpointerdown = (event) => {
        if (moveSwitch === true || focalLengthSwitch === true) return;

        stopAnimation();

        const { X, Y } = getClientPosition(event);

        moveSwitch = true;
        latestMoveX = X;
        latestMoveY = Y;
        latestBaseX = X;
        latestBaseY = Y;

        const displayRect = display.getBoundingClientRect();
        const relativeDiffX = X - displayRect.left - displayRadius;
        const relativeDiffY = Y - displayRect.top - displayRadius;
        const relativeDiffRadius = Math.pow(relativeDiffX * relativeDiffX + relativeDiffY * relativeDiffY, 1 / 2);
        moveType = relativeDiffRadius <= vectorSlideRadius ? 'vector' : 'rotate';
      };

      const documentMousemove = (event) => {
        const { X, Y } = getClientPosition(event);

        if (moveSwitch === true) {
          animationStartSwitch = true;
          clearTimeout(animationTimeout);
          animationTimeout = setTimeout(() => {
            moveStopCheck(X, Y);
          }, 100);
          latestMoveX = X;
          latestMoveY = Y;
          animate();
        } else if (focalLengthSwitch) {
          setFocalLength(X);
        } else if (mapMoveSwitch) {
          moveMap(X, Y);
        }
      };

      document.onpointerup = (event) => {
        if (moveSwitch === true) {
          moveSwitch = false;

          const { X, Y } = getClientPosition(event);
          latestMoveX = X;
          latestMoveY = Y;

          if (!animationSwitch && animationStartSwitch) {
            startAnimation();
          }
        }

        setFocalLengthSwitch(false);

        if (mapMoveSwitch) {
          mapMoveSwitch = false;
          mapBaseX = mapX;
          mapBaseY = mapY;
        }
      };

      document.onkeydown = (event) => {
        if (event.code !== 'Enter') return;
        // if (animationSwitch === false) {
        //   startAnimation();
        // } else {
        //   stopAnimation();
        // }
        output();
      };

      meter.onpointerdown = (event) => {
        setFocalLengthSwitch(true, getClientPosition(event).X);
      };

      mapDisplayWrapper.onpointerdown = (event) => {
        mapMoveSwitch = true;
        const { X, Y } = getClientPosition(event);
        latestPointerX = X;
        latestPointerY = Y;
      };

      if (typeof display.ontouchstart === 'object') {
        display.ontouchstart = displayOnpointerdown;
      } else {
        display.onpointerdown = displayOnpointerdown;
      }
      if (typeof document.ontouchmove === 'object') {
        document.ontouchmove = documentMousemove;
      } else {
        document.onmousemove = documentMousemove;
      }

      outputAuxiliaryLine();
      setMeterPosition(focalLengthPercentage / 2 - (1 / 4));
      makeLand();
    </script>
  </body>
</html>
